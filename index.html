<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8" />
    <title>Lantern Multi-Part</title>
    <style>
        body { margin: 0; overflow: hidden; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
    <script>
        // 場景、相機、渲染器
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 100;
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 環境光
        const ambient = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambient);

        // 黃色點光源（只影響zhezhou附近）
        const yellowLight = new THREE.PointLight(0xffff00, 20, 30); 
        yellowLight.position.set(0, 0, 0); // <--- 這裡設置為世界中心
        scene.add(yellowLight); // 直接加到scene

        // 光暈sprite（提前創建，後面直接用）
        const spriteMap = new THREE.TextureLoader().load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@master/examples/textures/lensflare/lensflare0.png');
        const spriteMaterial = new THREE.SpriteMaterial({
            map: spriteMap,
            color: 0xffff66,
            transparent: true,
            opacity: 0.5,
            depthWrite: false
        });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(16, 16, 1);
        sprite.position.set(0, 0, 0); // <--- 這裡設置為世界中心
        scene.add(sprite); 

        // 材質設置
        const mat_zhezhou = new THREE.MeshLambertMaterial({
            color: 0xff0000,
            transparent: true,
            opacity: 0.5
        });
        const mat_diaosheng = new THREE.MeshLambertMaterial({
            color: 0x4b2e0f,
            transparent: false
        });
        const mat_liusu = new THREE.MeshPhongMaterial({
            color: 0xffd700,
            shininess: 100,
            specular: 0xffffff
        });
        const mat_yuanpan = new THREE.MeshStandardMaterial({
            color: 0x222222,
            roughness: 0.6,
            metalness: 0.3
        });
        const mat_zhuzi = new THREE.MeshPhongMaterial({
            color: 0x8b0000,
            shininess: 80,
            specular: 0xffcccc
        });
        const mat_zhuziUP = new THREE.MeshPhongMaterial({
            color: 0x8b0000,
            shininess: 80,
            specular: 0xffcccc
        });

        // 部件配置
        const parts = [
            { file: 'model/FinalProject_zhezhou.stl', material: mat_zhezhou, isZhezhou: true },
            { file: 'model/FinalProject_diaosheng.stl', material: mat_diaosheng },
            { file: 'model/FinalProject_liusu.stl', material: mat_liusu },
            { file: 'model/FinalProject_yuanpan.stl', material: mat_yuanpan },
            { file: 'model/FinalProject_zhuzi.stl', material: mat_zhuzi },
            { file: 'model/FinalProject_zhuziUP.stl', material: mat_zhuziUP }
        ];

        // 用Group統一管理所有部件
        const group = new THREE.Group();
        scene.add(group);

        // 加載器
        const loader = new THREE.STLLoader();

        // 記錄所有mesh是否加載完成
        let loadedCount = 0;
        let meshes = [];

function centerGroupToWorld() {
    // 計算 group 的包圍盒
    const box = new THREE.Box3().setFromObject(group);
    const center = new THREE.Vector3();
    box.getCenter(center);
    // 將 group 的 position 設為 -center，讓其中心對齊世界中心
    group.position.sub(center);
}

        // 加載所有部件
parts.forEach((part, idx) => {
    loader.load(part.file, function (geometry) {
    const mesh = new THREE.Mesh(geometry, part.material);
    mesh.position.set(0, 0, 10); // 保持原有組裝關係
    mesh.scale.set(0.1, 0.1, 0.1);
    group.add(mesh);
    meshes[idx] = mesh;
    loadedCount++;
    if (loadedCount === parts.length) {
        centerGroupToWorld();
    }
        });
    });


        
function animate() {
    requestAnimationFrame(animate);
    if (loadedCount === parts.length) {
        group.rotation.y += 0.01;
        meshes.forEach(mesh => {
            if (mesh.position.z > 0) mesh.position.z -= 0.05;
            if (mesh.scale.x < 1) {
                mesh.scale.x += 0.01;
                mesh.scale.y += 0.01;
                mesh.scale.z += 0.01;
            }
        });
        // ***這裡不再有黃光和光暈跟隨的代碼***
    }
    renderer.render(scene, camera);
}
        animate();

        // 響應式
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
